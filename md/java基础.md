# java基础

### 一，变量  （数据类型 变量名 = 值；）

#### 1.命名

1. 驼峰命名：从第二个单词开始，后面所有单词的首字母大写
2. 不能以数字开头，只能以由字母（a_zA_Z）数字（0-9）下划线（_）美元符号（$）组成

#### 2.数据类型（基本数据类型和引用数据类型）

1. 基本数据类型：
   - 整型：byte 1个字节	 short 2个字节	 int 4个字节 		 long 8个字节
   - 浮点型：float 4个字节          double 8个字节
   - 字符型：char 2个字节
   - 布尔型：boolean

2.引用数据类型：字符串、数组、类、接口...

3.类型转换：隐式类型转换是小范围向大范围转换，强制类型转换是大范围向小范围转换

4.基本数据类型存在封装类，封装类为各个数据类型提供了一些数据操作方法，例如：

```
 String a = "21";int b = Integer.parseInt(a);//String 转int。
```

#### 3.局部变量和成员变量

1. 局部变量（形参、方法局部变量、代码块局部变量）：没有默认值，使用必须先初始化
2. 成员变量：系统会赋默认值   

局部变量和成员变量的区别https://www.cnblogs.com/newveg/p/6591435.html

代码块局部变量https://blog.csdn.net/megustas_jjc/article/details/52577216

java堆内存和栈内存的区别https://blog.csdn.net/chensi16114/article/details/72867260

#### 4.运算符

```
 && 短路的问题 只要逻辑&&的左边为 false ,逻辑&&的右边就不会运算
|| 短路的问题  只要逻辑||的左边为 true,逻辑||的右边就不会运算

num++ :先取变量(num)自身的值作为表达式的值,然后将变量自身+1
++num:先将变量自身的值+1,然后将变量的值作为表达式的值
总结: 不管是前自增还是后自增,变量自身的值都得+1
num--:先取变量(num)自身的值作为表达式的值,然后将变量自身-1
--num:先将变量自身的值-1,然后将变量的值作为表达式的值
总结:不管是前自减还是后自减,变量自身的值都得-1
注意区分是变量的值参与运算还是表达式的值参与运算
```



### 二,类和方法

#### 1.类和方法的定义：

1. 定义类的语法：https://zhidao.baidu.com/question/449527340.html

   ```
   权限修饰符 class 类名{
   	//类名的命名：从第一个单词开始，所有单词的首字母大写
     属性（成员变量）
     方法（成员方法）
   }
   ```

2.定义方法的语法：

```
权限修饰符 返回值类型 方法名（数据类型 参数名1，数据类型 参数名2...）{
  //方法名命名：从第二个单词开始每个单词的首字母大写
  //参数是外界用来传递数据的
  方法体
}
```

3.return语句https://blog.csdn.net/q2wxec/article/details/73302037

   return语句在try-catch-finally中的具体分析https://www.cnblogs.com/sonng/p/6065726.html

### 三，数组和字符串

#### 1.语法

1. 数组：数据类型[] 数组名 = new 数据类型[长度]；

   或者 数据类型[] 数组名 = {值1,值2,值3,...};

2. 字符串：String类的实例实现，查API调用方法

   ​    字符串一般用equals判断相等

   ​  java中String类http://www.360doc.com/content/14/1107/23/17130779_423471141.shtml

3. 了解多维数组

### 四，if结构和循环语句

#### 1.if结构

```
1.if（条件语句）{代码}
2.if（条件语句）{代码1}else{代码2}
3.if（条件1）{代码1}else if（条件2）{代码2}else{代码3}
```

#### 2.循环语句

```
 while 循环
	初始化语句;
 while(判断条件语句) {
			       循环体语句;
			        控制条件语句;
			      }
```

```
 do...while	循环
 初始化语句;
	do {
		 循环体语句;
		 控制条件语句;
	 }while(判断条件语句);
```

```
for 循环
 for(初始化表达式;条件表达式;循环后的操作表达式) {
		            循环体;
 }
```

```
增强for循环
for(数据类型 变量名 : 要遍历的集合或者数组) {
					循环体;
}
```

```
如何运用while（true）{循环体}  
break:结束当前循环
continue:跳过本次循环,执行下一次循环
循环次数已知优先选择for循环
```

#### 3.eclipse

eclipse反编译插件https://blog.csdn.net/try_try_try/article/details/77853784

eclipse代码规范插件https://github.com/alibaba/p3c/tree/master/eclipse-plugin

- [ ] ###### debug调试

### 五，面向对象入门

#### 1.创建对象

一个类可以创建多个对象，类名 对象名 =new 类名（）；

#### 2.封装

概述：隐藏对象的属性和实现细节，仅对外提供公共访问的方法。

可以通过private关键字实现，private关键字修饰的内容只能在本类中直接访问，所以需要对外提供公共的访问方式：get和set方法。

#### 3.this关键字

概述：代表本类当前对象的引用

作用：区分成员变量和局部变量

注意：java中使用变量遵循就近原则

#### 4.构造方法

```
作用：创建对象；对象的初始化
注意：类中必定有构造方法，如果不写，系统会自动添加无参构造；构造方法和其他方法一样可以重载
格式：
	无参构造方法
	public 类名（）{}
	
	有参构造方法
	public 类名（参数列表）{
      构造方法中参数的作用：往往是给成员变量赋值的，所以参数的名字就是成员变量名
      用this获取成员变量
	}
```

```
写类的步骤：
			1.成员变量；
			2.有参构造（无参构造）；
			3.成员方法
```

#### 5.static关键字

概述：用于修饰成员变量和成员方法，当一个属性是被该类下所有的对象所共享的时候可以考虑使用静态

特点：

```
1.静态随类的加载而加载；
2.静态内容优先于对象存在；
3.被static修饰的内容，能被该类下所有的对象所共享；
4.可以类名点的形式直接调用
```
```
注意：1.静态方法中没有this关键字
	 2.静态只能直接访问静态
	*（this指代的是当前的对象，Static方法在类加载时就已经存在了，但是对象是在创建时才在内存中生成。）
	*（一个类的静态成员中去访问非静态成员之所以会出错是因为在类的非静态成员不存在的时候静态成员就已经存在了）
```
了解类的加载和初始化https://blog.csdn.net/w1lgy/article/details/53823772

#### 6.final关键字

- final关键字修饰的变量只能赋值一次；
- 修饰的方法不能被子类重写；
- 修饰的类不能被继承，但可以继承别的类。
- 如果final修饰的是引用数据类型的数据：则是地址值不能改变，但是对象的属性值可以改变。https://ask.csdn.net/questions/210697

#### 7.工具类

一般工具类的文件名为：功能名称+Utils；

工具类里面的方法一般都是被static修饰的静态方法；

工具类的构造方法可以用private进行修饰，来防止创建对象；

可以通过类名.方法或类名.成员变量使用

```
常用工具类：
```

#### 8.泛型和包装类

```
泛型：
	概述：泛指某种特定的数据类型，表示形式为：<>，泛型的类型参数只能是引用数据类型。
	好处：提高代码安全性
```

```
包装类：
		概述：其实就是基本数据类型对应的引用数据类型	
		自动拆装箱(JDK1.5的新特性)
		自动装箱: 就是把基本类型的数据转成对应的引用数据类型.
		Integer i = 10;
		自动拆箱: 就是把引用类型的数据转成对应的基本数据类型.
		Integer i = 10;int a = i;
```

java泛型https://blog.csdn.net/sunxianghuang/article/details/51982979

java的自动装箱拆箱http://www.importnew.com/15712.html

#### 9.继承

//概述：实际开发中，如果多个类中的内容相似，我们可以把这些内容提取出来单独放到一个类中，然后让那多个类和这个类产生关系，这个关系就是继承。

```
格式：
	public class 类A extends 类B{}
	类A：子类，派生类
	类B：父类，超类
```

```
继承的特点：
		1.在java中，继承只允许单继承，不允许多继承，但支持多层继承；
		2.子类继承父类，就拥有父类的所有非私有属性和非私有方法。
		3.继承中成员变量的访问特点：使用变量遵循"就近原则"，先在局部找，没有就去本类成员位置找，没有就去父类成员位置找，没有就报错。
```

```
继承的好处：
		1.提高代码复用性；
		2.提高代码的维护性；
		3.让类和类产生关系。（多态的前提条件）
开发原则：高内聚低耦合（内聚：自己完成某个功能的能力；耦合性：类和类之间的相互影响程度）
```

```
继承的注意事项：
			1.子类无法继承父类的私有成员；
			2.子类无法继承父类的构造方法，但可以使用父类的构造方法：**需要访问父类的构造方法必须使用super关键字，访问父类的空参构造super（），访问父类的有参构造super（参数列表）；**默认访问空参构造：因为所有类都直接或间接的继承Object类，Object类是所有类的父类，Object类只有一个空参构造
```

```
this和super的区别：
				this代表本类当前对象的引用，谁调用，this就代表谁；
				super代表本类当前对象的父类的内存空间标识（可以理解为父类的引用）
```

#### 10.方法的重写（重写、重载、重定义）

使用super.父类方法名（）实现父类的功能

方法的重写就是子类出现和父类一模一样的方法，但该方法具备了子类特有的功能，该方法就称之为方法重写

```
注意事项：
		1.父类的私有方法子类不能重写
		2.方法重写时，子类的访问权限不能低于父类
		3.静态方法只能覆盖静态方法（https://blog.csdn.net/gao_zhennan/article/details/72892946）
访问权限修饰符：
		public 当前项目 同一个包，不同包
		protected：同一个包 子父类 同一个类
		Default：同一个包 同一个类
		private：同一个类	
```

### 六，集合

概述：用来存储长度不固定元素的容器

常用的两个集合类：

#### 1.HashMap

```
HashMap:无序，双列集合，键具有唯一性，值可以重复
put（）；//添加元素（键值对）如果该键是第一次添加,返回null, 如果键是重复添加,会用新值去覆盖旧值,并返回旧值.
size（）；//获取长度（键值对的对数）
get（）；根据键，获取其对应的值，如果键不存在,就返回null
isEmpty（）；//是否为空
containsKey() containsValue（）；//判断是否包含给定的键、值
clear（）；//清空集合中所有的元素
remove（）；//根据键移除该键值对，如果键存在,就移除该键值对并返回值, 如果键不存在就返回null
```

#### 2.ArrayList

```
ArrayList:有序，可重复
 		add(Object value);   //添加元素
        get(int index);      //根据索引获取对应的元素.
        set(int index,Object value);    //把指定索引位置改成指定值
        remove(int index);  //根据索引移除元素
        isEmpty();          //判断集合是否为空
        indexOf();          //返回指定元素在集合中第一次出现的位置, 如果元素不存在,返回-1
        lastIndexOf();      //返回指定元素在集合中最后一次出现的位置, 如果元素不存在,返回-1
        size();             //获取集合的长度(元素的个数)
        toArray();          //把集合转成对应的数组
        //Arrays.toString(数组对象);    //把数组转成其对应的字符串形式(快速打印数组的内容)
```

#### 3.增强for遍历双列集合

```
例1
public static void main(String[] args) {
		/*单列集合:
		Collection:
		 			List:  ArrayList
		 			Set:   HashSet TreeSet  			
		 	双列集合:
		 		Map:
		 			HashMap */
//		HashMap集合的遍历
		HashMap<Integer, String> map = new HashMap<>();
		map.put(1, "v1");
		map.put(2, "v2");
		map.put(3, "v3");
		map.put(4, "v4");
		map.put(5, "v5");
		map.put(6, "v6");	
//		1.获取到该集合中所有的键
		Set<Integer> keySet = map.keySet(); // Set集合是单列集合
//		2.遍历所有的键,拿到每一个键
		for(Integer temp : keySet) {
//		3.根据键取值 temp 就是代表键
			String value = map.get(temp);
			System.out.println(temp + "....." + value);
		}
例2
HashMap<String,String> people;
people = new HashMap<>();
people.put("name","张三");
people.put("id","8877678");

for(String k: people.keySet()){
    System.out.println(k);
}
```

**了解集合的嵌套及遍历https://blog.csdn.net/euller/article/details/54232748

//正则表达式

### 七，抽象类、接口和多态

#### 1.抽象类

概述：有抽象方法的类一定是抽象类（或者接口），抽象类中不一定有抽象方法。

```
public abstract class Animal {...}
特点：
	1.有抽象方法的类一定是抽象类（或者接口），抽象类用关键字abstract修饰（抽象方法就是用abstract修饰的方法，没有方法体）
	2.抽象类不能创建对象实例化，可以通过创建其子类对象完成实例化，多态（Animal animal = new Cat（）；）
	3.抽象类有构造方法，用于子类对象访问父类数据前，对父类数据进行初始化
	4.抽象类的子类，如果也是抽象类，可以不用重写抽象方法，如果是普通类，必须重写父类中的所有抽象方法。
```

```
//不能和abstract关键字共存的关键字：
	static: 静态方法可以被类名点的形式调用, 但是抽象方法是没有方法体的, 这样做没有意义, 所以不能同存。
	private: 表示私有的意思, 被它修饰的方法不能被子类重写, 但是抽象方法要求子类必须重写, 所以属于设计冲突。
	final: 表示最终的意思, 被它修饰的方法不能被子类重写, 但是抽象方法要求子类必须重写, 所以属于设计冲突。
```

#### 2.接口

```
权限修饰符 interface 接口名 {抽象方法}
接口不是类，因为接口中没有构造方法；(//比抽象类更加抽象)
特点：
	1. 接口用 interface 关键字表示.
	2. 类实现接口用 implements 关键字表示.
	3. 接口中没有构造方法的.
接口的子类：如果也是抽象类，可以不用重写父类的抽象方法，如果是普通类，就必须重写父类接口中的所有抽象方法。
```

```
//接口的成员特点：
JDK1.7及其以前:
接口中的成员有且只能有: 抽象方法或者是常量.
抽象方法的默认修饰符: public abstract
常量的默认修饰符: public static final
JDK1.8之后:
接口中可以定义有方法体的方法了,
如果是静态可以直接写, 如果是非静态方法, 必须加default.
```

#### 3.类和接口之间的关系

```
类与接口之间的关系:
		类与类: 继承关系, 只能单继承, 不能多继承, 但是可以多层继承.
		类与接口: 实现关系, 可以单实现, 可以多实现, 还可以在继承一个类的同时实现多个接口.
		接口与接口: 继承关系, 可以单继承,也可以多继承.
//抽象类和接口的区别是什么:
	1.成员特点不同
		抽象类中的成员比普通类多一种抽象方法(而且抽象方法也可以不写)
		接口中有且只能有抽象方法(JDK1.8以后可以有带方法体的方法)或者常量.
	2.关系特点不同
		参考上个知识点
	3.设计理念不同
		抽象类: 定义的是整个继承体系的 共性内容.
		接口: 定义的是整个继承体系的 扩展内容.
```

#### 4.多态

```
概述:
	同一事物在不同时刻表现出来的不同形态(状态).
前提条件:
	1.必须要有继承(或者实现)关系.
	2.要有父类(父接口)引用指向子类对象.
	3.要有方法重写.
```

```
**多态的访问特点:
	成员变量:
		编译看左边, 运行看左边.
	成员方法:
		静态: 编译看左边, 运行看左边.
	非静态: 编译看左边, 运行看右边.
总结: (记忆)
	只有非静态方法是编译看左边,运行看右边, 其他都是编译和运行都看左边.
	原因是因为: 只有非静态方法有 方法重写.
```

```
多态的好处
	1.提高代码的扩展性.
	2.提高代码的可维护性.
**多态在实际开发中最常用的应用场景:
	父类型可以作为方法的形参的参数类型, 这样可以接受其任意的子类对象.
	代码示例:
	public static void test(Person p) { 
		p.eat();
	}
多态的弊端:
	父类(父接口)引用 不能直接使用子类的特有成员(成员变量和成员方法).
解决：可以通过向下转型实现.
向上转型和向下转型: 这个概念是针对于引用类型的
	Person person = new Student();	向上转型
	Student s = (Student)person;	向下转型
隐式类型转换和强制类型转换: 这个概念是针对于基本类型的
	double d = 10;	隐式类型转换
	int a = (int)d;	强制类型转换
```

